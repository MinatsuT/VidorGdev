diff -Naur arduino_16550_uart/arduino_16550_uart_hw.tcl arduino_16550_uart_mod/arduino_16550_uart_hw.tcl
--- arduino_16550_uart/arduino_16550_uart_hw.tcl	2018-11-29 13:30:10.136770249 +0100
+++ arduino_16550_uart_mod/arduino_16550_uart_hw.tcl	2018-11-29 13:38:58.924765644 +0100
@@ -16,7 +16,7 @@
 # ------------------------------------------------------------------------------
 # Module altera_16550_uart
 # ------------------------------------------------------------------------------
-set_module_property NAME                           altera_16550_uart
+set_module_property NAME                           arduino_16550_uart
 set_module_property VERSION                        18.1
 set_module_property DISPLAY_NAME                   "16550 Compatible UART Intel FPGA IP"
 set_module_property DESCRIPTION                    "UART with run-time configurability and 16550 compatible register space"
diff -Naur arduino_16550_uart/arduino_16550_uart_sw.tcl arduino_16550_uart_mod/arduino_16550_uart_sw.tcl
--- arduino_16550_uart/arduino_16550_uart_sw.tcl	2018-11-29 13:30:10.136770249 +0100
+++ arduino_16550_uart_mod/arduino_16550_uart_sw.tcl	2018-11-29 13:39:42.708765263 +0100
@@ -1,25 +1,25 @@
 # (C) 2001-2018 Intel Corporation. All rights reserved.
-# Your use of Intel Corporation's design tools, logic functions and other 
-# software and tools, and its AMPP partner logic functions, and any output 
-# files from any of the foregoing (including device programming or simulation 
-# files), and any associated documentation or information are expressly subject 
-# to the terms and conditions of the Intel Program License Subscription 
-# Agreement, Intel FPGA IP License Agreement, or other applicable 
-# license agreement, including, without limitation, that your use is for the 
-# sole purpose of programming logic devices manufactured by Intel and sold by 
-# Intel or its authorized distributors.  Please refer to the applicable 
+# Your use of Intel Corporation's design tools, logic functions and other
+# software and tools, and its AMPP partner logic functions, and any output
+# files from any of the foregoing (including device programming or simulation
+# files), and any associated documentation or information are expressly subject
+# to the terms and conditions of the Intel Program License Subscription
+# Agreement, Intel FPGA IP License Agreement, or other applicable
+# license agreement, including, without limitation, that your use is for the
+# sole purpose of programming logic devices manufactured by Intel and sold by
+# Intel or its authorized distributors.  Please refer to the applicable
 # agreement for further details.
 
 
 #
-# altera_16550_uart_driver.tcl
+# arduino_16550_uart_driver.tcl
 #
 
 # Create a new driver
-create_driver altera_16550_uart_driver
+create_driver arduino_16550_uart_driver
 
-# Associate it with some hardware known as "altera_16550_uart"
-set_sw_property hw_class_name altera_16550_uart
+# Associate it with some hardware known as "arduino_16550_uart"
+set_sw_property hw_class_name arduino_16550_uart
 
 # The version of this driver
 set_sw_property version 18.1
@@ -49,17 +49,17 @@
 #
 
 # C/C++ source files
-add_sw_property c_source HAL/src/altera_16550_uart_fd.c
-add_sw_property c_source HAL/src/altera_16550_uart_init.c
-add_sw_property c_source HAL/src/altera_16550_uart_ioctl.c
-add_sw_property c_source HAL/src/altera_16550_uart_read.c
-add_sw_property c_source HAL/src/altera_16550_uart_write.c
+add_sw_property c_source HAL/src/arduino_16550_uart_fd.c
+add_sw_property c_source HAL/src/arduino_16550_uart_init.c
+add_sw_property c_source HAL/src/arduino_16550_uart_ioctl.c
+add_sw_property c_source HAL/src/arduino_16550_uart_read.c
+add_sw_property c_source HAL/src/arduino_16550_uart_write.c
 
 
 # Include files
-add_sw_property include_source HAL/inc/altera_16550_uart.h
-add_sw_property include_source HAL/inc/altera_16550_uart_fd.h
-add_sw_property include_source inc/altera_16550_uart_regs.h
+add_sw_property include_source HAL/inc/arduino_16550_uart.h
+add_sw_property include_source HAL/inc/arduino_16550_uart_fd.h
+add_sw_property include_source inc/arduino_16550_uart_regs.h
 
 
 # This driver supports HAL & UCOSII BSP (OS) types
diff -Naur arduino_16550_uart/HAL/inc/arduino_16550_uart_fd.h arduino_16550_uart_mod/HAL/inc/arduino_16550_uart_fd.h
--- arduino_16550_uart/HAL/inc/arduino_16550_uart_fd.h	2018-11-29 13:30:10.140770249 +0100
+++ arduino_16550_uart_mod/HAL/inc/arduino_16550_uart_fd.h	2018-11-29 13:32:28.788769042 +0100
@@ -41,42 +41,41 @@
 /*
  * Externally referenced routines
  */
-extern int altera_16550_uart_read_fd (alt_fd* fd, wchar_t* ptr, int len);
-extern int altera_16550_uart_write_fd (alt_fd* fd, const wchar_t* ptr,
-  int len);
+extern int arduino_16550_uart_read_fd (alt_fd* fd, alt_u8* ptr, int len);
+extern int arduino_16550_uart_write_fd (alt_fd* fd, const alt_u8* ptr, int len);
 
 /*
  * Device structure definition. This is needed by alt_sys_init in order to 
  * reserve memory for the device instance.
  */
-typedef struct altera_16550_uart_dev_s
+typedef struct arduino_16550_uart_dev_s
 {
   alt_dev                 dev;
-  altera_16550_uart_state state;
-} altera_16550_uart_dev;
+  arduino_16550_uart_state state;
+} arduino_16550_uart_dev;
 
-extern int altera_16550_uart_ioctl_fd (alt_fd* fd, int req, void* arg);
-extern int altera_16550_uart_close_fd(alt_fd* fd);
+extern int arduino_16550_uart_ioctl_fd (alt_fd* fd, int req, void* arg);
+extern int arduino_16550_uart_close_fd(alt_fd* fd);
 
-#ifdef ALTERA_16550_UART_USE_IOCTL
-#define ALTERA_16550_UART_IOCTL_FD altera_16550_uart_ioctl_fd
+#ifdef ARDUINO_16550_UART_USE_IOCTL
+#define ARDUINO_16550_UART_IOCTL_FD arduino_16550_uart_ioctl_fd
 #else
-#define ALTERA_16550_UART_IOCTL_FD NULL
-#endif //#ifdef ALTERA_16550_UART_USE_IOCTL
+#define ARDUINO_16550_UART_IOCTL_FD NULL
+#endif //#ifdef ARDUINO_16550_UART_USE_IOCTL
 
-#define ALTERA_16550_UART_DEV_INSTANCE(name, d)       \
-  static altera_16550_uart_dev d =                     \
+#define ARDUINO_16550_UART_DEV_INSTANCE(name, d)       \
+  static arduino_16550_uart_dev d =                     \
    {                                                   \
      {                                                 \
        ALT_LLIST_ENTRY,                                \
        name##_NAME,                                    \
        NULL, /* open */                                \
-       altera_16550_uart_close_fd,                     \
-       altera_16550_uart_read_fd,                      \
-       altera_16550_uart_write_fd,                     \
+       arduino_16550_uart_close_fd,                     \
+       arduino_16550_uart_read_fd,                      \
+       arduino_16550_uart_write_fd,                     \
        NULL, /* lseek */                               \
        NULL, /* fstat */                               \
-       ALTERA_16550_UART_IOCTL_FD,                    \
+       ARDUINO_16550_UART_IOCTL_FD,                    \
      },    \
      {\
       ALT_LLIST_ENTRY,                                \
@@ -86,9 +85,9 @@
      }\
    }
 
-#define ALTERA_16550_UART_DEV_INIT(name, d)           \
+#define ARDUINO_16550_UART_DEV_INIT(name, d)           \
   {                                                    \
-    ALTERA_16550_UART_STATE_INIT(name, d.state);      \
+    ARDUINO_16550_UART_STATE_INIT(name, d.state);      \
                                                        \
     /* make the device available to the system */      \
     alt_dev_reg(&d.dev);                               \
diff -Naur arduino_16550_uart/HAL/inc/arduino_16550_uart.h arduino_16550_uart_mod/HAL/inc/arduino_16550_uart.h
--- arduino_16550_uart/HAL/inc/arduino_16550_uart.h	2018-11-29 13:30:10.140770249 +0100
+++ arduino_16550_uart_mod/HAL/inc/arduino_16550_uart.h	2018-11-29 13:32:05.332769246 +0100
@@ -77,13 +77,13 @@
  *
  * An instance of this structure is created in the auto-generated
  * alt_sys_init.c file for each UART listed in the systems SOPCINFO file. This is
- * done using the ALTERA_16550_UART_STATE_INSTANCE macro given below.
+ * done using the ARDUINO_16550_UART_STATE_INSTANCE macro given below.
  */
 
 typedef enum stopbit      { STOPB_1 = 0,STOPB_2 } StopBit;
 typedef enum paritybit    { ODD_PARITY = 0, EVEN_PARITY, MARK_PARITY, SPACE_PARITY, NO_PARITY } ParityBit;
 typedef enum databit      { CS_5 = 0, CS_6, CS_7, CS_8, CS_9 = 256} DataBit;
-typedef enum baud 
+typedef enum baud
 {
     BR9600 = B9600,
     BR19200 = B19200,
@@ -93,82 +93,85 @@
 } Baud;
 typedef enum rx_fifo_level_e { RXONECHAR = 0, RXQUARTER, RXHALF, RXFULL } Rx_FifoLvl;
 typedef enum tx_fifo_level_e { TXEMPTY = 0, TXTWOCHAR, TXQUARTER, TXHALF } Tx_FifoLvl;
-typedef struct uart_config_s 
+typedef struct uart_config_s
 {
-    StopBit    stop_bit;
-    ParityBit  parity_bit;
-    DataBit    data_bit;
-    Baud       baudrate;
-    alt_u32    fifo_mode;
-    Rx_FifoLvl rx_fifo_level;
-    Tx_FifoLvl tx_fifo_level;
-    alt_u32    hwfc;
+    StopBit     stop_bit;
+    ParityBit   parity_bit;
+    DataBit     data_bit;
+    Baud        baudrate;
+    alt_u32     fifo_mode;
+    Rx_FifoLvl  rx_fifo_level;
+    Tx_FifoLvl  tx_fifo_level;
+    alt_u32     hwfc;
 } UartConfig;
 typedef struct LSR_s
 {
-  alt_u8	dr:1;
-  alt_u8	oe:1;
-  alt_u8	pe:1;
-  alt_u8	fe:1;
-  alt_u8	bi:1;
-  alt_u8	thre:1;
-  alt_u8	temt:1;
-  alt_u8	rfe:1;
+    alt_u8      dr:1;
+    alt_u8      oe:1;
+    alt_u8      pe:1;
+    alt_u8      fe:1;
+    alt_u8      bi:1;
+    alt_u8      thre:1;
+    alt_u8      temt:1;
+    alt_u8      rfe:1;
 }line_status_reg;
-typedef struct altera_16550_uart_state_s
+typedef struct arduino_16550_uart_state_s
 {
- alt_dev               dev;
- void*                 base;                 /* The base address of the device */
- alt_u32               clock;
- alt_u32               hwfifomode;
- alt_u32               ctrl;                 /* Shadow value of the LSR register */
- volatile alt_u32      rx_start;             /* Start of the pending receive data */
- volatile alt_u32      rx_end;               /* End of the pending receive data */
- volatile alt_u32      tx_start;             /* Start of the pending transmit data */
- volatile alt_u32      tx_end;               /* End of the pending transmit data */
- alt_u32               freq;                 /* Current clock freq rate */
- UartConfig            config;               /* Uart setting */
- #ifdef ALTERA_16550_UART_USE_IOCTL
- struct termios        termios;
- #endif
- alt_u32               flags;                /* Configuration flags */
- ALT_FLAG_GRP         (events)               /* Event flags used for
-                                              * foreground/background in mult-threaded
-                                              * mode */
- ALT_SEM              (read_lock)            /* Semaphore used to control access to the
-                                              * read buffer in multi-threaded mode */
- ALT_SEM              (write_lock)           /* Semaphore used to control access to the
-                                              * write buffer in multi-threaded mode */
- volatile wchar_t      rx_buf[ALT_16550_UART_BUF_LEN]; /* The receive buffer */
- volatile wchar_t      tx_buf[ALT_16550_UART_BUF_LEN]; /* The transmit buffer */
-line_status_reg	      line_status; /* line register status for the current read byte data of RBR or data at the top of FIFO*/
-alt_u8                error_ignore; /* received data will be discarded
-for the current read byte data of RBR or data at the top of FIFO if pe, fe and bi errors detected after error_ignore is set to '0' */
-} altera_16550_uart_state;
-
-alt_u32 alt_16550_uart_config(altera_16550_uart_state* sp, UartConfig *setting);
-int altera_16550_uart_close(altera_16550_uart_state* sp, int flags);
-altera_16550_uart_state* altera_16550_uart_open (const char *name);
-int altera_16550_uart_read(altera_16550_uart_state* sp, wchar_t* ptr, int len, int flags);
-int altera_16550_uart_write(altera_16550_uart_state* sp, const wchar_t* ptr, int len, int flags);
+    alt_dev               dev;
+    void*                 base;                 /* The base address of the device */
+    alt_u32               clock;
+    alt_u32               hwfifomode;
+    alt_u32               ctrl;                 /* Shadow value of the LSR register */
+    volatile alt_u32      rx_start;             /* Start of the pending receive data */
+    volatile alt_u32      rx_end;               /* End of the pending receive data */
+    volatile alt_u32      tx_start;             /* Start of the pending transmit data */
+    volatile alt_u32      tx_end;               /* End of the pending transmit data */
+    alt_u32               freq;                 /* Current clock freq rate */
+    UartConfig            config;               /* Uart setting */
+    #ifdef ARDUINO_16550_UART_USE_IOCTL
+    struct termios        termios;
+    #endif
+    alt_u32               flags;                /* Configuration flags */
+    ALT_FLAG_GRP         (events)               /* Event flags used for
+                                                  * foreground/background in mult-threaded
+                                                  * mode */
+    ALT_SEM              (read_lock)            /* Semaphore used to control access to the
+                                                  * read buffer in multi-threaded mode */
+    ALT_SEM              (write_lock)           /* Semaphore used to control access to the
+                                                  * write buffer in multi-threaded mode */
+    volatile alt_u8       rx_buf[ALT_16550_UART_BUF_LEN]; /* The receive buffer */
+    volatile alt_u8       tx_buf[ALT_16550_UART_BUF_LEN]; /* The transmit buffer */
+    line_status_reg       line_status; /* line register status for the current read byte data of RBR or data at the top of FIFO*/
+    alt_u8                error_ignore; /* received data will be discarded
+                                          for the current read byte data of RBR or data at the top of FIFO if pe, fe and bi errors detected after error_ignore is set to '0' */
+} arduino_16550_uart_state;
+
+alt_u32 alt_16550_uart_config(arduino_16550_uart_state* sp, UartConfig *setting);
+int arduino_16550_uart_close(arduino_16550_uart_state* sp, int flags);
+arduino_16550_uart_state* arduino_16550_uart_open (const char *name);
+int arduino_16550_uart_read(arduino_16550_uart_state* sp, alt_u8* ptr, int len, int flags);
+int arduino_16550_uart_write(arduino_16550_uart_state* sp, const alt_u8* ptr, int len, int flags);
+void arduino_16550_uart_flush(arduino_16550_uart_state* sp);
+
+void arduino_16550_uart_isrrx(void (*pIsr)(void*), void* arg);
 
 /*
- * The macro ALTERA_16550_UART_INSTANCE is used by the auto-generated file
+ * The macro ARDUINO_16550_UART_INSTANCE is used by the auto-generated file
  * alt_sys_init.c to create an instance of this device driver state.
  */
 
 
-typedef int (*ALTERA_16550_UART_OPEN)  (alt_fd* fd, const char* name, int flags, int mode);
-typedef int (*ALTERA_16550_UART_CLOSE) (alt_fd* fd);
+typedef int (*ARDUINO_16550_UART_OPEN)  (alt_fd* fd, const char* name, int flags, int mode);
+typedef int (*ARDUINO_16550_UART_CLOSE) (alt_fd* fd);
 
-#define ALTERA_16550_UART_STATE_INSTANCE(name, state) \
-  altera_16550_uart_state state =            \
+#define ARDUINO_16550_UART_STATE_INSTANCE(name, state) \
+  arduino_16550_uart_state state =            \
 {                                   \
  {                                  \
        ALT_LLIST_ENTRY,             \
        name##_NAME,                 \
-       ((ALTERA_16550_UART_OPEN)(altera_16550_uart_open)),      \
-       ((ALTERA_16550_UART_CLOSE)(altera_16550_uart_close)),     \
+       ((ARDUINO_16550_UART_OPEN)(arduino_16550_uart_open)),      \
+       ((ARDUINO_16550_UART_CLOSE)(arduino_16550_uart_close)),     \
        NULL,                        \
        NULL,                        \
        NULL,                        \
@@ -180,19 +183,19 @@
        name##_FIFO_MODE,            \
 }
 /*
- * altera_avalon_uart_init() is called by the auto-generated function
+ * arduino_avalon_uart_init() is called by the auto-generated function
  * alt_sys_init() for each UART in the system. This is done using the
- * ALTERA_16550_UART_INIT macro given below.
+ * ARDUINO_16550_UART_INIT macro given below.
  *
  * This function is responsible for performing all the run time initilisation
  * for a device instance, i.e. registering the interrupt handler, and
  * regestering the device with the system.
  */
-extern void altera_16550_uart_init(altera_16550_uart_state* sp,
+extern void arduino_16550_uart_init(arduino_16550_uart_state* sp,
  alt_u32 irq_controller_id, alt_u32 irq);
 
 /*
- * The macro ALTERA_16550_UART_STATE_INIT is used by the auto-generated file
+ * The macro ARDUINO_16550_UART_STATE_INIT is used by the auto-generated file
  * alt_sys_init.c to initialize an instance of the device driver state.
  *
  * This macro performs a sanity check to ensure that the interrupt has been
@@ -200,7 +203,7 @@
  * generated at build time.
  */
 
-#define ALTERA_16550_UART_STATE_INIT(name, state)                    \
+#define ARDUINO_16550_UART_STATE_INIT(name, state)                    \
  if (name##_IRQ == ALT_IRQ_NOT_CONNECTED)                            \
  {                                                                   \
   ALT_LINK_ERROR ("Error: Interrupt not connected for " #name ". "   \
@@ -214,30 +217,30 @@
  }                                                                   \
  else                                                                \
  {                                                                   \
-  altera_16550_uart_init(&state, name##_IRQ_INTERRUPT_CONTROLLER_ID, \
+  arduino_16550_uart_init(&state, name##_IRQ_INTERRUPT_CONTROLLER_ID, \
    name##_IRQ);                                                      \
  }
 
 /*
  * Include in case non-direct version of driver required.
  */
-#include "altera_16550_uart_fd.h"
+#include "arduino_16550_uart_fd.h"
 
-#ifdef ALTERA_16550_UART_USE_IOCTL
+#ifdef ARDUINO_16550_UART_USE_IOCTL
 
-#define ALTERA_16550_UART_INSTANCE(name, dev) \
-   ALTERA_16550_UART_DEV_INSTANCE(name, dev)
-#define ALTERA_16550_UART_INIT(name, dev) \
-   ALTERA_16550_UART_DEV_INIT(name, dev)
+#define ARDUINO_16550_UART_INSTANCE(name, dev) \
+   ARDUINO_16550_UART_DEV_INSTANCE(name, dev)
+#define ARDUINO_16550_UART_INIT(name, dev) \
+   ARDUINO_16550_UART_DEV_INIT(name, dev)
 
-#else /* !ALTERA_16550_UART_USE_IOCTL */
+#else /* !ARDUINO_16550_UART_USE_IOCTL */
 
-#define ALTERA_16550_UART_INSTANCE(name, state) \
-   ALTERA_16550_UART_STATE_INSTANCE(name, state)
-#define ALTERA_16550_UART_INIT(name, state) \
-   ALTERA_16550_UART_STATE_INIT(name, state)
+#define ARDUINO_16550_UART_INSTANCE(name, state) \
+   ARDUINO_16550_UART_STATE_INSTANCE(name, state)
+#define ARDUINO_16550_UART_INIT(name, state) \
+   ARDUINO_16550_UART_STATE_INIT(name, state)
 
-#endif /* ALTERA_16550_UART_USE_IOCTL */
+#endif /* ARDUINO_16550_UART_USE_IOCTL */
 
 #ifdef __cplusplus
 }
diff -Naur arduino_16550_uart/HAL/src/arduino_16550_uart_fd.c arduino_16550_uart_mod/HAL/src/arduino_16550_uart_fd.c
--- arduino_16550_uart/HAL/src/arduino_16550_uart_fd.c	2018-11-29 13:30:10.140770249 +0100
+++ arduino_16550_uart_mod/HAL/src/arduino_16550_uart_fd.c	2018-11-29 13:33:12.476768661 +0100
@@ -30,60 +30,58 @@
 
 #include "alt_types.h"
 #include "sys/alt_dev.h"
-#include "altera_16550_uart.h"
+#include "arduino_16550_uart.h"
 
-extern int altera_16550_uart_read(altera_16550_uart_state* sp, 
-    wchar_t* ptr, int len, int flags);
-extern int altera_16550_uart_write(altera_16550_uart_state* sp, 
-    const wchar_t* ptr, int len, int flags);
-extern int altera_16550_uart_ioctl(altera_16550_uart_state* sp, 
+extern int arduino_16550_uart_read(arduino_16550_uart_state* sp,
+    alt_u8* ptr, int len, int flags);
+extern int arduino_16550_uart_write(arduino_16550_uart_state* sp,
+    const alt_u8* ptr, int len, int flags);
+extern int arduino_16550_uart_ioctl(arduino_16550_uart_state* sp,
     int req, void* arg);
-extern int altera_16550_uart_close(altera_16550_uart_state* sp, int flags);
+extern int arduino_16550_uart_close(arduino_16550_uart_state* sp, int flags);
 
 /* ----------------------------------------------------------------------- */
 /* --------------------- WRAPPERS FOR ALT FD SUPPORT --------------------- */
 /*
  *
  */
-int 
-altera_16550_uart_read_fd(alt_fd* fd, wchar_t* ptr, int len)
+int arduino_16550_uart_read_fd(alt_fd* fd, alt_u8* ptr, int len)
 {
-    altera_16550_uart_dev* dev = (altera_16550_uart_dev*) fd->dev; 
+    arduino_16550_uart_dev* dev = (arduino_16550_uart_dev*) fd->dev; 
 
-    return altera_16550_uart_read(&dev->state, ptr, len,
+    return arduino_16550_uart_read(&dev->state, ptr, len,
       fd->fd_flags);
 }
 
-int 
-altera_16550_uart_write_fd(alt_fd* fd, const wchar_t* buffer, int space)
+int arduino_16550_uart_write_fd(alt_fd* fd, const alt_u8* buffer, int space)
 {
-    altera_16550_uart_dev* dev = (altera_16550_uart_dev*) fd->dev; 
+    arduino_16550_uart_dev* dev = (arduino_16550_uart_dev*) fd->dev; 
 
-    return altera_16550_uart_write(&dev->state, buffer, space,
+    return arduino_16550_uart_write(&dev->state, buffer, space,
       fd->fd_flags);
 }
 
 /*
  * To reduce the code footprint of this driver, the ioctl() function is not
  * included by default. If you wish to use the ioctl features provided 
- * below, you can do so by adding the option : -DALTERA_16550_UART_USE_IOCTL
+ * below, you can do so by adding the option : -DARDUINO_16550_UART_USE_IOCTL
  * to CPPFLAGS in the Makefile (or through the Eclipse IDE).
  */
-#ifdef ALTERA_16550_UART_USE_IOCTL
+#ifdef ARDUINO_16550_UART_USE_IOCTL
 
 int 
-altera_16550_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
+arduino_16550_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
 {
-    altera_16550_uart_dev* dev = (altera_16550_uart_dev*) fd->dev;
+    arduino_16550_uart_dev* dev = (arduino_16550_uart_dev*) fd->dev;
 
-    return altera_16550_uart_ioctl(&dev->state, req, arg);
+    return arduino_16550_uart_ioctl(&dev->state, req, arg);
 }
-#endif /* ALTERA_16550_UART_USE_IOCTL */
+#endif /* ARDUINO_16550_UART_USE_IOCTL */
 
 int 
-altera_16550_uart_close_fd(alt_fd* fd)
+arduino_16550_uart_close_fd(alt_fd* fd)
 {
-    altera_16550_uart_dev* dev = (altera_16550_uart_dev*) fd->dev; 
+    arduino_16550_uart_dev* dev = (arduino_16550_uart_dev*) fd->dev; 
 
-    return altera_16550_uart_close(&dev->state, fd->fd_flags);
+    return arduino_16550_uart_close(&dev->state, fd->fd_flags);
 }
diff -Naur arduino_16550_uart/HAL/src/arduino_16550_uart_init.c arduino_16550_uart_mod/HAL/src/arduino_16550_uart_init.c
--- arduino_16550_uart/HAL/src/arduino_16550_uart_init.c	2018-11-29 13:30:10.140770249 +0100
+++ arduino_16550_uart_mod/HAL/src/arduino_16550_uart_init.c	2018-11-29 13:35:27.084767489 +0100
@@ -33,36 +33,47 @@
 #include "sys/alt_irq.h"
 #include "sys/ioctl.h"
 #include "sys/alt_errno.h"
-#include "altera_16550_uart.h"
-#include "altera_16550_uart_regs.h"
+#include "arduino_16550_uart.h"
+#include "arduino_16550_uart_regs.h"
 #include  <sys/alt_llist.h>
 
 ALT_LLIST_HEAD(alt_16550_uart_list);
 
+#define SEC_RAM __attribute__((__section__(".rwdata")))
+
+void (*pIsrRx)(void*);
+void *pIsrArg;
+
+void arduino_16550_uart_isrrx(void (*pIsr)(void*), void* arg)
+{
+    pIsrRx  = pIsr;
+    pIsrArg = arg;
+}
+
 /*
- * altera_16550_uart_rxirq() is called by altera_16550_uart_irq() to
+ * arduino_16550_uart_rxirq() is called by arduino_16550_uart_irq() to
  * process a receive interrupt. It transfers the incoming character into
  * the receive circular buffer, and sets the appropriate flags to indicate
  * that there is data ready to be processed.
  */
-void altera_16550_uart_rxirq(altera_16550_uart_state* sp)
+void SEC_RAM arduino_16550_uart_rxirq(arduino_16550_uart_state* sp)
 {
     alt_u32 next;
     alt_u32 regs;
 
     if(!(sp->error_ignore))
     {
-    	/* If there was an error, discard the data */
-    	if (sp->line_status.pe |
-		sp->line_status.fe |
-        	sp->line_status.bi)
-    	{
-		/* discard data from RBR/ 1st byte data at the top of FIFO */
-    		IORD_ALTERA_16550_UART_RBR(sp->base); 
-    		return;	
-    	}
+        /* If there was an error, discard the data */
+        if (sp->line_status.pe |
+            sp->line_status.fe |
+            sp->line_status.bi)
+        {
+            /* discard data from RBR/ 1st byte data at the top of FIFO */
+            IORD_ARDUINO_16550_UART_RBR(sp->base);
+            return;
+        }
     }
-    
+
     /*
      * In a multi-threaded environment, set the read event flag to indicate
      * that there is data ready. This is only done if the circular buffer was
@@ -83,45 +94,38 @@
         do
         {
             /* Transfer data from the device to the circular buffer */
-            sp->rx_buf[sp->rx_end] = IORD_ALTERA_16550_UART_RBR(sp->base);
+            sp->rx_buf[sp->rx_end] = IORD_ARDUINO_16550_UART_RBR(sp->base);
             sp->rx_end = next;
 
             next = (sp->rx_end + 1) & ALT_16550_UART_BUF_MSK;
-            regs = IORD_ALTERA_16550_UART_LSR (sp->base);
+            regs = IORD_ARDUINO_16550_UART_LSR (sp->base);
 
-        } while ((regs & ALTERA_16550_UART_LSR_DR_MSK) && (next != sp->rx_start));
+        } while ((regs & ARDUINO_16550_UART_LSR_DR_MSK) && (next != sp->rx_start));
 
     } else
     {
         /* Transfer data from the device to the circular buffer */
-        sp->rx_buf[sp->rx_end] = IORD_ALTERA_16550_UART_RBR(sp->base);
+        sp->rx_buf[sp->rx_end] = IORD_ARDUINO_16550_UART_RBR(sp->base);
 
         sp->rx_end = next;
 
         next = (sp->rx_end + 1) & ALT_16550_UART_BUF_MSK;
     }
-    /*
-     * If the cicular buffer was full, disable interrupts. Interrupts will be
-     * re-enabled when data is removed from the buffer.
-     */
 
-    if (next == sp->rx_start)
+    if (pIsrRx)
     {
-        sp->ctrl &= ~ALTERA_16550_UART_IER_ERBFI_MSK;
-        IOWR_ALTERA_16550_UART_IER(sp->base, sp->ctrl);
+        pIsrRx(pIsrArg);
     }
-
 }
 
 
 /*
- * altera_16550_uart_txirq() is called by altera_16550_uart_irq() to
+ * arduino_16550_uart_txirq() is called by arduino_16550_uart_irq() to
  * process a transmit interrupt. It transfers data from the transmit
  * buffer to the device, and sets the apropriate flags to indicate that
  * there is data ready to be processed.
  */
-void
-altera_16550_uart_txirq(altera_16550_uart_state* sp)
+void SEC_RAM arduino_16550_uart_txirq(arduino_16550_uart_state* sp)
 {
     alt_u32 regs;
     /* Transfer data if there is some ready to be transfered */
@@ -141,7 +145,7 @@
         }
         /* Write the data to the device */
         /* If fifo enable continuously drain circular buffer to tx fifo */
-        regs = IORD_ALTERA_16550_UART_LSR(sp->base);
+        regs = IORD_ARDUINO_16550_UART_LSR(sp->base);
         if (sp->config.fifo_mode)
         {
             /* Fill up Tx FIFO from circular buffer until TX FIFO FULl
@@ -149,22 +153,24 @@
              */
             do
             {
-            	if(regs & ALTERA_16550_UART_LSR_THRE_MSK)
-            	{
-            		IOWR_ALTERA_16550_UART_THR(sp->base, sp->tx_buf[sp->tx_start]);
-            		sp->tx_start = (++sp->tx_start) & ALT_16550_UART_BUF_MSK;
-            	}
-            	regs = IORD_ALTERA_16550_UART_LSR(sp->base);
+                if(regs & ARDUINO_16550_UART_LSR_THRE_MSK)
+                {
+                    IOWR_ARDUINO_16550_UART_THR(sp->base, sp->tx_buf[sp->tx_start]);
+                    sp->tx_start = (++sp->tx_start) & ALT_16550_UART_BUF_MSK;
+                }
+                regs = IORD_ARDUINO_16550_UART_LSR(sp->base);
             } while (sp->tx_start != sp->tx_end);
         } else
         {
-            IOWR_ALTERA_16550_UART_THR(sp->base, sp->tx_buf[sp->tx_start]);
+            alt_u32 data;
+            data = (alt_u8)sp->tx_buf[sp->tx_start];
+            IOWR_ARDUINO_16550_UART_THR(sp->base, data);
             sp->tx_start = (++sp->tx_start) & ALT_16550_UART_BUF_MSK;
             /*
              * In case the transmit interrupt had previously been disabled by
              * detecting a low value on CTS, it is re-enabled here.
              */
-            sp->ctrl |= ALTERA_16550_UART_IER_ETBEI_MSK;
+            sp->ctrl |= ARDUINO_16550_UART_IER_ETBEI_MSK;
         }
 
     }
@@ -177,32 +183,32 @@
 
     if (sp->tx_start == sp->tx_end)
     {
-        sp->ctrl &= ~(ALTERA_16550_UART_IER_ETBEI_MSK);
+        sp->ctrl &= ~(ARDUINO_16550_UART_IER_ETBEI_MSK);
     }
-    IOWR_ALTERA_16550_UART_IER(sp->base, sp->ctrl);
+    IOWR_ARDUINO_16550_UART_IER(sp->base, sp->ctrl);
 }
 
 /*
- * altera_16550_uart_irq() is the interrupt handler registered at
+ * arduino_16550_uart_irq() is the interrupt handler registered at
  * configuration time for processing UART interrupts. It vectors
- * interrupt requests to either altera_16550_uart_rxirq() (for incoming
- * data), or altera_16550_uart_txirq() (for outgoing data).
+ * interrupt requests to either arduino_16550_uart_rxirq() (for incoming
+ * data), or arduino_16550_uart_txirq() (for outgoing data).
  */
 #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
-static void altera_16550_uart_irq(void* context)
+static void SEC_RAM arduino_16550_uart_irq(void* context)
 #else
-static void altera_16550_uart_irq(void* context, alt_u32 id)
+static void SEC_RAM arduino_16550_uart_irq(void* context, alt_u32 id)
 #endif
 {
     alt_u32 status = 0;
-    altera_16550_uart_state* sp = (altera_16550_uart_state*) context;
+    arduino_16550_uart_state* sp = (arduino_16550_uart_state*) context;
     void* base               = sp->base;
 
     /*
      * Read the status register in order to determine the cause of the
      * interrupt.
      */
-    status = IORD_ALTERA_16550_UART_LSR(base);
+    status = IORD_ARDUINO_16550_UART_LSR(base);
     sp->line_status.dr = status;
     sp->line_status.oe = status >> 1;
     sp->line_status.pe = status >> 2;
@@ -213,18 +219,18 @@
     sp->line_status.rfe = status >> 7;
 
     /* Dummy read to ensure IRQ is negated before ISR returns */
-    IORD_ALTERA_16550_UART_LSR(base);
+    IORD_ARDUINO_16550_UART_LSR(base);
 
     /* process a read irq */
     if (sp->line_status.dr)
     {
-        altera_16550_uart_rxirq(sp);
+        arduino_16550_uart_rxirq(sp);
     }
 
     /* process a write irq */
     if (sp->line_status.thre)
     {
-        altera_16550_uart_txirq(sp);
+        arduino_16550_uart_txirq(sp);
     }
 }
 
@@ -236,7 +242,7 @@
  * descriptor associated with the relevant stream (i.e. stdout) can be closed
  * as well. This routine does not manage file descriptors.
  */
-int altera_16550_uart_close(altera_16550_uart_state* sp, int flags)
+int arduino_16550_uart_close(arduino_16550_uart_state* sp, int flags)
 {
     /*
      * Wait for all transmit data to be emptied by the UART ISR.
@@ -251,12 +257,12 @@
   return 0;
 }
 
-altera_16550_uart_state* altera_16550_uart_open (const char *name)
+arduino_16550_uart_state* arduino_16550_uart_open (const char *name)
 {
-    altera_16550_uart_state *sp;
+    arduino_16550_uart_state *sp;
 
     /* Find requested device */
-    sp = (altera_16550_uart_state*) alt_find_dev (name, &alt_16550_uart_list);
+    sp = (arduino_16550_uart_state*) alt_find_dev (name, &alt_16550_uart_list);
     if (sp == NULL)
     {
         return NULL;
@@ -264,16 +270,16 @@
     return sp;
 }
 
-alt_u32 alt_16550_uart_config(altera_16550_uart_state* sp, UartConfig *setting)
+alt_u32 alt_16550_uart_config(arduino_16550_uart_state* sp, UartConfig *setting)
 {
     alt_u32 regs;
     alt_u32 divisor;
-    alt_u32 LCR = IORD_ALTERA_16550_UART_LCR(sp->base);
+    alt_u32 LCR = IORD_ARDUINO_16550_UART_LCR(sp->base);
 
     if (sp->config.baudrate != setting->baudrate)
     {
         /* Set LCR [7] to program Divisor */
-        IOWR_ALTERA_16550_UART_LCR(sp->base, (LCR | ALTERA_16550_UART_LCR_DLAB_MSK));
+        IOWR_ARDUINO_16550_UART_LCR(sp->base, (LCR | ARDUINO_16550_UART_LCR_DLAB_MSK));
         // Formula for calculating the divisor:
         //    baudrate = clock / (16 * divisor)
         // => baudrate * 16 * divisor = clock
@@ -281,12 +287,12 @@
         // => divisor = (clock / 16) / baudrate
         divisor = sp->clock / (16*(setting->baudrate));
 
-        IOWR_ALTERA_16550_UART_DLL(sp->base, (divisor & 0x00FF));
-        IOWR_ALTERA_16550_UART_DLH(sp->base, ((divisor >> 8)& 0x00FF));
+        IOWR_ARDUINO_16550_UART_DLL(sp->base, (divisor & 0x00FF));
+        IOWR_ARDUINO_16550_UART_DLH(sp->base, ((divisor >> 8)& 0x00FF));
 
         /* Clear LCR[7] after program Divisor */
-        IOWR_ALTERA_16550_UART_LCR (sp->base, (LCR & ~(ALTERA_16550_UART_LCR_DLAB_MSK)));
-    #ifdef ALTERA_16550_UART_USE_IOCTL
+        IOWR_ARDUINO_16550_UART_LCR (sp->base, (LCR & ~(ARDUINO_16550_UART_LCR_DLAB_MSK)));
+    #ifdef ARDUINO_16550_UART_USE_IOCTL
         /* Update Device Termios Settings */
         sp->config.baudrate = sp->termios.c_ispeed = sp->termios.c_ospeed = setting->baudrate;
     #endif
@@ -294,7 +300,7 @@
 
     if (sp->config.data_bit != setting->data_bit)
     {
-        LCR &= ~(ALTERA_16550_UART_LCR_DLS_MSK);
+        LCR &= ~(ARDUINO_16550_UART_LCR_DLS_MSK);
         LCR |= (setting->data_bit);
         /* Update Device Settings */
         sp->config.data_bit = setting->data_bit;
@@ -304,11 +310,11 @@
     {
         if (setting->parity_bit == NO_PARITY)
         {
-            LCR &= ~(ALTERA_16550_UART_LCR_PEN_MSK);
+            LCR &= ~(ARDUINO_16550_UART_LCR_PEN_MSK);
          } else
          {
-            LCR &= ~(ALTERA_16550_UART_LCR_EPS_MSK);
-            LCR |= (((setting->parity_bit)<< 4) | ALTERA_16550_UART_LCR_PEN_MSK);
+            LCR &= ~(ARDUINO_16550_UART_LCR_EPS_MSK);
+            LCR |= (((setting->parity_bit)<< 4) | ARDUINO_16550_UART_LCR_PEN_MSK);
          }
         /* Update Device Settings */
         sp->config.parity_bit = setting->parity_bit;
@@ -316,19 +322,19 @@
 
     if (sp->config.stop_bit != setting->stop_bit)
     {
-        LCR &= ~(ALTERA_16550_UART_LCR_STOP_MSK);
+        LCR &= ~(ARDUINO_16550_UART_LCR_STOP_MSK);
         LCR |= ((setting->stop_bit)<< 2);
         /* Update Device Settings */
         sp->config.stop_bit = setting->stop_bit;
     }
-    IOWR_ALTERA_16550_UART_LCR(sp->base, LCR);
+    IOWR_ARDUINO_16550_UART_LCR(sp->base, LCR);
 
     /* FIFO mode configuration
      * hardware FIFO mode must be enable first and
      * user select fifo enabled */
     if (sp->hwfifomode && (setting->fifo_mode))
     {
-        regs = ALTERA_16550_UART_FCR_FIFOE_MSK;
+        regs = ARDUINO_16550_UART_FCR_FIFOE_MSK;
         sp->config.fifo_mode = setting->fifo_mode;
 
         if (sp->config.rx_fifo_level != setting->rx_fifo_level)
@@ -336,7 +342,7 @@
             /* Update device setting*/
             sp->config.rx_fifo_level = setting->rx_fifo_level;
         }
-        regs &= ~(ALTERA_16550_UART_FCR_RT_MSK);
+        regs &= ~(ARDUINO_16550_UART_FCR_RT_MSK);
         regs |= sp->config.rx_fifo_level << 6;
 
         if (sp->config.tx_fifo_level != setting->tx_fifo_level)
@@ -344,52 +350,51 @@
             /* Update device setting*/
             sp->config.tx_fifo_level = setting->tx_fifo_level;
         }
-        regs &= ~(ALTERA_16550_UART_FCR_TET_MSK);
+        regs &= ~(ARDUINO_16550_UART_FCR_TET_MSK);
         regs |= sp->config.tx_fifo_level << 4;
         /* Program FCR with setting updated */
-        IOWR_ALTERA_16550_UART_FCR(sp->base, regs);
+        IOWR_ARDUINO_16550_UART_FCR(sp->base, regs);
 
         if (sp->config.hwfc != setting->hwfc)
         {
-		    regs = IORD_ALTERA_16550_UART_MCR(sp->base);
-		    if (setting->hwfc)
-			{
-                regs |= ALTERA_16550_UART_MCR_RTS_MSK;
-                IOWR_ALTERA_16550_UART_MCR(sp->base, regs);
+            regs = IORD_ARDUINO_16550_UART_MCR(sp->base);
+            if (setting->hwfc)
+            {
+                regs |= ARDUINO_16550_UART_MCR_RTS_MSK;
+                IOWR_ARDUINO_16550_UART_MCR(sp->base, regs);
 
                 regs |= ((setting->hwfc)<< 5);
-                IOWR_ALTERA_16550_UART_MCR(sp->base, regs);
-		    } else
-			{   
-			    /* Disable Autoflow Control */
-			    IOWR_ALTERA_16550_UART_MCR(sp->base, (regs & ~(ALTERA_16550_UART_MCR_AFCE_MSK)));
-		    }
+                IOWR_ARDUINO_16550_UART_MCR(sp->base, regs);
+            } else
+            {
+                /* Disable Autoflow Control */
+                IOWR_ARDUINO_16550_UART_MCR(sp->base, (regs & ~(ARDUINO_16550_UART_MCR_AFCE_MSK)));
+            }
             /* Update device setting*/
-            sp->config.hwfc = setting->hwfc;				
+            sp->config.hwfc = setting->hwfc;
         }
 
     } else
     {
         /* Disable Fifo enable and other level trigger */
-        IOWR_ALTERA_16550_UART_FCR(sp->base, 0x0);
+        IOWR_ARDUINO_16550_UART_FCR(sp->base, 0x0);
         /* Disable HWFC */
-        regs = (IORD_ALTERA_16550_UART_MCR(sp->base) &
-                ~(ALTERA_16550_UART_MCR_AFCE_MSK));
-        IOWR_ALTERA_16550_UART_MCR(sp->base, regs);
+        regs = (IORD_ARDUINO_16550_UART_MCR(sp->base) &
+                ~(ARDUINO_16550_UART_MCR_AFCE_MSK));
+        IOWR_ARDUINO_16550_UART_MCR(sp->base, regs);
        }
     return 0;
 }
 
 
 /*
- * altera_16550_uart_init() is called by the auto-generated function
+ * arduino_16550_uart_init() is called by the auto-generated function
  * alt_sys_init() in order to initialize a particular instance of this device.
  * It is responsible for configuring the device and associated software
  * constructs.
  */
- void
-altera_16550_uart_init(altera_16550_uart_state* sp,
-  alt_u32 irq_controller_id,  alt_u32 irq)
+void arduino_16550_uart_init(arduino_16550_uart_state* sp,
+                             alt_u32 irq_controller_id,  alt_u32 irq)
 {
     extern alt_llist alt_16550_uart_list;
     void* base = sp->base;
@@ -399,20 +404,20 @@
     error = (alt_dev_llist_insert((alt_dev_llist*) sp, &alt_16550_uart_list));
     /* Initialize UART register */
     /* Flush Tx and Rx FIFO */
-    IOWR_ALTERA_16550_UART_FCR(base, ALTERA_16550_UART_FCR_FIFOE_MSK);
-    IOWR_ALTERA_16550_UART_FCR(base, ALTERA_16550_UART_FCR_FIFOE_MSK |
-                                     ALTERA_16550_UART_FCR_FIFOR_MSK |
-                                     ALTERA_16550_UART_FCR_XFIFOR_MSK);
-    IOWR_ALTERA_16550_UART_FCR(base, 0x0);
+    IOWR_ARDUINO_16550_UART_FCR(base, ARDUINO_16550_UART_FCR_FIFOE_MSK);
+    IOWR_ARDUINO_16550_UART_FCR(base, ARDUINO_16550_UART_FCR_FIFOE_MSK |
+                                     ARDUINO_16550_UART_FCR_FIFOR_MSK |
+                                     ARDUINO_16550_UART_FCR_XFIFOR_MSK);
+    IOWR_ARDUINO_16550_UART_FCR(base, 0x0);
     /* Clear any Error status */
-    IORD_ALTERA_16550_UART_LSR(sp->base);
-    IORD_ALTERA_16550_UART_RBR(sp->base);
-    IORD_ALTERA_16550_UART_IIR(sp->base);
-    IORD_ALTERA_16550_UART_MSR(sp->base);
+    IORD_ARDUINO_16550_UART_LSR(sp->base);
+    IORD_ARDUINO_16550_UART_RBR(sp->base);
+    IORD_ARDUINO_16550_UART_IIR(sp->base);
+    IORD_ARDUINO_16550_UART_MSR(sp->base);
     /* Configure default settings */
-    IOWR_ALTERA_16550_UART_LCR(base, ((ODD_PARITY << 4) | ALTERA_16550_UART_LCR_PEN_MSK
+    IOWR_ARDUINO_16550_UART_LCR(base, ((ODD_PARITY << 4) | ARDUINO_16550_UART_LCR_PEN_MSK
                                       | (STOPB_1 << 2)| CS_8));
-#ifdef ALTERA_16550_UART_USE_IOCTL                                   
+#ifdef ARDUINO_16550_UART_USE_IOCTL
     sp->termios.c_cflag = PAODD | PARENB | CSTOPB | CS8;
     sp->termios.c_ispeed = sp->termios.c_ospeed = B115200;
 #endif
@@ -429,18 +434,43 @@
     if (!error)
     {
         /* register the interrupt handler */
-    #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
-        alt_ic_isr_register(irq_controller_id, irq, altera_16550_uart_irq, sp, 0x0);
-    #else
-        alt_irq_register (irq, sp, altera_16550_uart_irq);
-    #endif
-	
-	    /* enable interrupts at the device */
-        regs = IORD_ALTERA_16550_UART_IER(sp->base);
-        regs |= ALTERA_16550_UART_IER_ERBFI_MSK  |
-                ALTERA_16550_UART_IER_ETBEI_MSK;
-        IOWR_ALTERA_16550_UART_IER(base, sp->ctrl);
+#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
+        alt_ic_isr_register(irq_controller_id, irq, arduino_16550_uart_irq, sp, 0x0);
+#else
+        alt_irq_register (irq, sp, arduino_16550_uart_irq);
+#endif
 
+        /* enable interrupts at the device */
+        regs = IORD_ARDUINO_16550_UART_IER(sp->base);
+        regs |= ARDUINO_16550_UART_IER_ERBFI_MSK  |
+                ARDUINO_16550_UART_IER_ETBEI_MSK;
+        sp->ctrl = regs;
+        IOWR_ARDUINO_16550_UART_IER(base, sp->ctrl);
     }
 }
 
+/**
+ */
+void arduino_16550_uart_flush(arduino_16550_uart_state* sp)
+{
+  void* base = sp->base;
+
+  /* Flush Tx and Rx FIFO */
+  IOWR_ARDUINO_16550_UART_FCR(base, ARDUINO_16550_UART_FCR_FIFOE_MSK);
+  IOWR_ARDUINO_16550_UART_FCR(base, ARDUINO_16550_UART_FCR_FIFOE_MSK |
+                                    ARDUINO_16550_UART_FCR_FIFOR_MSK |
+                                    ARDUINO_16550_UART_FCR_XFIFOR_MSK);
+  IOWR_ARDUINO_16550_UART_FCR(base, 0x0);
+
+  /* Clear any Error status */
+  IORD_ARDUINO_16550_UART_LSR(base);
+  IORD_ARDUINO_16550_UART_RBR(base);
+  IORD_ARDUINO_16550_UART_IIR(base);
+  IORD_ARDUINO_16550_UART_MSR(base);
+
+  /* reset tx and rx buffers */
+  sp->tx_start = 0;
+  sp->tx_end   = 0;
+  sp->rx_start = 0;
+  sp->rx_end   = 0;
+}
diff -Naur arduino_16550_uart/HAL/src/arduino_16550_uart_ioctl.c arduino_16550_uart_mod/HAL/src/arduino_16550_uart_ioctl.c
--- arduino_16550_uart/HAL/src/arduino_16550_uart_ioctl.c	2018-11-29 13:30:10.140770249 +0100
+++ arduino_16550_uart_mod/HAL/src/arduino_16550_uart_ioctl.c	2018-11-29 13:35:52.644767266 +0100
@@ -35,12 +35,12 @@
 #include "sys/ioctl.h"
 #include "sys/alt_errno.h"
 
-#include "altera_16550_uart_regs.h"
-#include "altera_16550_uart.h"
+#include "arduino_16550_uart_regs.h"
+#include "arduino_16550_uart.h"
 
-#ifdef ALTERA_16550_UART_USE_IOCTL
+#ifdef ARDUINO_16550_UART_USE_IOCTL
 /*
- * altera_16550_uart_ioctl() is called by the system ioctl() function to handle
+ * arduino_16550_uart_ioctl() is called by the system ioctl() function to handle
  * ioctl requests for the UART. The only ioctl requests supported are TIOCMGET
  * and TIOCMSET.
  *
@@ -52,23 +52,23 @@
  * through the input argument "arg".
  */
 
-static int altera_16550_uart_tiocmget(altera_16550_uart_state* sp,
+static int arduino_16550_uart_tiocmget(arduino_16550_uart_state* sp,
   struct termios* term);
-static int altera_16550_uart_tiocmset(altera_16550_uart_state* sp,
+static int arduino_16550_uart_tiocmset(arduino_16550_uart_state* sp,
   struct termios* term);
 
 int 
-altera_16550_uart_ioctl(altera_16550_uart_state* sp, int req, void* arg)
+arduino_16550_uart_ioctl(arduino_16550_uart_state* sp, int req, void* arg)
 {
   int rc = -ENOTTY;
 
   switch (req)
   {
   case TIOCMGET:
-    rc = altera_16550_uart_tiocmget(sp, (struct termios*) arg);
+    rc = arduino_16550_uart_tiocmget(sp, (struct termios*) arg);
     break;
   case TIOCMSET:
-    rc = altera_16550_uart_tiocmset(sp, (struct termios*) arg);
+    rc = arduino_16550_uart_tiocmset(sp, (struct termios*) arg);
     break;
   default:
     break;
@@ -77,14 +77,14 @@
 }
 
 /*
- * altera_16550_uart_tiocmget() is used by altera_16550_uart_ioctl() to fill
+ * arduino_16550_uart_tiocmget() is used by arduino_16550_uart_ioctl() to fill
  * in the input termios structure with the current device configuration. 
  *
  * See termios.h for further details on the contents of the termios structure.
  */
 
 static int 
-altera_16550_uart_tiocmget(altera_16550_uart_state* sp,
+arduino_16550_uart_tiocmget(arduino_16550_uart_state* sp,
   struct termios* term)
 {
   memcpy (term, &sp->termios, sizeof (struct termios));
@@ -92,7 +92,7 @@
 }
 
 /*
- * altera_16550_uart_tiocmset() is used by altera16550_uart_ioctl() to 
+ * arduino_16550_uart_tiocmset() is used by arduino16550_uart_ioctl() to 
  * configure the device according to the settings in the input termios 
  * structure. In practice the only configuration that can be changed is the
  * baud rate, and then only if the hardware is configured to have a writable
@@ -100,7 +100,7 @@
  */
 
 static int 
-altera_16550_uart_tiocmset(altera_16550_uart_state* sp,
+arduino_16550_uart_tiocmset(arduino_16550_uart_state* sp,
   struct termios* term)
 {
     speed_t speed;
@@ -151,4 +151,4 @@
     }
   return 0;
 }
-#endif /* ALTERA_16550_UART_USE_IOCTL */
\ No newline at end of file
+#endif /* ARDUINO_16550_UART_USE_IOCTL */
\ No newline at end of file
diff -Naur arduino_16550_uart/HAL/src/arduino_16550_uart_read.c arduino_16550_uart_mod/HAL/src/arduino_16550_uart_read.c
--- arduino_16550_uart/HAL/src/arduino_16550_uart_read.c	2018-11-29 13:30:10.140770249 +0100
+++ arduino_16550_uart_mod/HAL/src/arduino_16550_uart_read.c	2018-11-29 13:36:51.060766757 +0100
@@ -34,20 +34,22 @@
 #include "sys/ioctl.h"
 #include "sys/alt_errno.h"
 
-#include "altera_16550_uart.h"
-#include "altera_16550_uart_regs.h"
+#include "arduino_16550_uart.h"
+#include "arduino_16550_uart_regs.h"
+
+#define SEC_RAM __attribute__((__section__(".rwdata")))
 
 /*
- * altera_16550_uart_read() is called by the system read() function in order to
+ * arduino_16550_uart_read() is called by the system read() function in order to
  * read a block of data from the UART. "len" is the maximum length of the data
  * to read, and "ptr" indicates the destination address. "sp" is the state
  * pointer for the device to be read from.
  *
- * Permission checks are made before the call to altera_16550_uart_read(), so
+ * Permission checks are made before the call to arduino_16550_uart_read(), so
  * we know that the file descriptor has been opened with the correct permissions
  * for this operation.
  *
- * The return value is the number of 2 bytes(because supporting CS_9) actually 
+ * The return value is the number of 2 bytes(because supporting CS_9) actually
  * read.
  *
  * This function does not communicate with the device directly. Instead data is
@@ -55,36 +57,35 @@
  * for copying data from the device into this buffer.
  */
 
-int 
-altera_16550_uart_read(altera_16550_uart_state* sp, wchar_t* ptr, int len,
-  int flags)
+int SEC_RAM arduino_16550_uart_read(arduino_16550_uart_state* sp,
+                                    alt_u8* ptr, int len, int flags)
 {
-	alt_irq_context context;
-	int             block;
-	//alt_u32         next;
-	alt_u8          read_would_block = 0;
-	int             count = 0;
+    alt_irq_context context;
+    int             block;
+    //alt_u32         next;
+    alt_u8          read_would_block = 0;
+    int             count = 0;
 
-	sp->ctrl = IORD_ALTERA_16550_UART_IER(sp->base);
-	/*
+    sp->ctrl = IORD_ARDUINO_16550_UART_IER(sp->base);
+    /*
      * Construct a flag to indicate whether the device is being accessed in
      * blocking or non-blocking mode.
      */
-	block = !(flags & O_NONBLOCK);
+    block = !(flags & O_NONBLOCK);
 
-	/*
+    /*
      * When running in a multi threaded environment, obtain the "read_lock"
      * semaphore. This ensures that reading from the device is thread-safe.
      */
-	ALT_SEM_PEND (sp->read_lock, 0);
+    ALT_SEM_PEND (sp->read_lock, 0);
 
-	/*
+    /*
      * Calculate which slot in the circular buffer is the next one to read
      * data from.
      */
-	//next = (sp->rx_start + 1) & ALT_16550_UART_BUF_MSK;
+    //next = (sp->rx_start + 1) & ALT_16550_UART_BUF_MSK;
 
-	/*
+    /*
      * Loop, copying data from the circular buffer to the destination address
      * supplied in "ptr". This loop is terminated when the required number of
      * bytes have been read. If the circular buffer is empty, and no data has
@@ -94,74 +95,74 @@
      * transferred, or the device is being accessed in non-blocking mode, then
      * the loop terminates without necessarily reading all the requested data.
      */
-	do
-	{
-		/*
-		 * Read the required amount of data, until the circular buffer runs
+    do
+    {
+        /*
+         * Read the required amount of data, until the circular buffer runs
          * empty
          */
-		while ((count < len) && (sp->rx_start != sp->rx_end))
-		{
-			count++;
-			*ptr++ = sp->rx_buf[sp->rx_start];
-
-			sp->rx_start = (++sp->rx_start) & ALT_16550_UART_BUF_MSK;
-		}
-		/*
+        while ((count < len) && (sp->rx_start != sp->rx_end))
+        {
+            count++;
+            *ptr++ = sp->rx_buf[sp->rx_start];
+
+            sp->rx_start = (++sp->rx_start) & ALT_16550_UART_BUF_MSK;
+        }
+        /*
          * If no data has been transferred, the circular buffer is empty, and
          * this is not a non-blocking access, block waiting for data to arrive.
          */
-		if (!count && (sp->rx_start == sp->rx_end))
-		{
-			if (!block)
-			{
-				/* Set errno to indicate the reason we're not returning any data */
-				ALT_ERRNO = EWOULDBLOCK;
-				read_would_block = 1;
-				break;
-			} else
-			{
-				/* Block waiting for some data to arrive */
-				/* First, ensure read interrupts are enabled to avoid deadlock */
-				context = alt_irq_disable_all ();
-				sp->ctrl |= ALTERA_16550_UART_IER_ERBFI_MSK;
-				IOWR_ALTERA_16550_UART_IER(sp->base, sp->ctrl);
-				alt_irq_enable_all (context);
+        if (!count && (sp->rx_start == sp->rx_end))
+        {
+            if (!block)
+            {
+                /* Set errno to indicate the reason we're not returning any data */
+                ALT_ERRNO = EWOULDBLOCK;
+                read_would_block = 1;
+                break;
+            } else
+            {
+                /* Block waiting for some data to arrive */
+                /* First, ensure read interrupts are enabled to avoid deadlock */
+                context = alt_irq_disable_all ();
+                sp->ctrl |= ARDUINO_16550_UART_IER_ERBFI_MSK;
+                IOWR_ARDUINO_16550_UART_IER(sp->base, sp->ctrl);
+                alt_irq_enable_all (context);
 
-				/*
+                /*
                  * When running in a multi-threaded mode, we pend on the read event
                  * flag set in the interrupt service routine. This avoids wasting CPU
                  * cycles waiting in this thread, when we could be doing something more
                  * profitable elsewhere.
                  */
-				ALT_FLAG_PEND (sp->events,
-						       ALT_16550_UART_READ_RDY,
-						       OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
-						       0);
-			}
-		}
-	}
-	while (!count && len);
-	/*
-	 * Now that access to the circular buffer is complete, release the read
-     * semaphore so that other threads can access the buffer.
-     */
+                ALT_FLAG_PEND (sp->events,
+                              ALT_16550_UART_READ_RDY,
+                              OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
+                              0);
+            }
+        }
+    }
+    while (!count && len);
+    /*
+      * Now that access to the circular buffer is complete, release the read
+      * semaphore so that other threads can access the buffer.
+      */
     ALT_SEM_POST (sp->read_lock);
     /*
      * Ensure that interrupts are enabled, so that the circular buffer can
      * re-fill.
      */
     context = alt_irq_disable_all ();
-    sp->ctrl |= ALTERA_16550_UART_IER_ERBFI_MSK;
-    IOWR_ALTERA_16550_UART_IER(sp->base, sp->ctrl);
+    sp->ctrl |= ARDUINO_16550_UART_IER_ERBFI_MSK;
+    IOWR_ARDUINO_16550_UART_IER(sp->base, sp->ctrl);
     alt_irq_enable_all (context);
     /* Return the number of bytes read */
     if(read_would_block)
     {
-    	return ~EWOULDBLOCK;
-    }else
+        return ~EWOULDBLOCK;
+    } else
     {
-    	return count;
+        return count;
     }
 }
 
diff -Naur arduino_16550_uart/HAL/src/arduino_16550_uart_write.c arduino_16550_uart_mod/HAL/src/arduino_16550_uart_write.c
--- arduino_16550_uart/HAL/src/arduino_16550_uart_write.c	2018-11-29 13:30:10.140770249 +0100
+++ arduino_16550_uart_mod/HAL/src/arduino_16550_uart_write.c	2018-11-29 13:37:07.396766615 +0100
@@ -35,20 +35,22 @@
 #include "sys/ioctl.h"
 #include "sys/alt_errno.h"
 
-#include "altera_16550_uart_regs.h"
-#include "altera_16550_uart.h"
+#include "arduino_16550_uart_regs.h"
+#include "arduino_16550_uart.h"
+
+#define SEC_RAM __attribute__((__section__(".rwdata")))
 
 /*
- * altera_16550_uart_write() is called by the system write() function in order
- * to write a block of data to the UART. "len" is the length of the data to 
+ * arduino_16550_uart_write() is called by the system write() function in order
+ * to write a block of data to the UART. "len" is the length of the data to
  * write, and "ptr" indicates the source address. "sp" is the state pointer
  * for the device to be written to.
  *
- * Permission checks are made before the call to altera_16550_uart_write(), so
+ * Permission checks are made before the call to arduino_16550_uart_write(), so
  * we know that the file descriptor has been opened with the correct permissions
  * for this operation.
  *
- * The return value is the number of 2 bytes(because supporting CS_9) actually 
+ * The return value is the number of 2 bytes(because supporting CS_9) actually
  * written.
  *
  * This function does not communicate with the device directly. Instead data is
@@ -56,16 +58,15 @@
  * for copying data from this buffer into the device.
  */
 
-int
-altera_16550_uart_write(altera_16550_uart_state* sp, const wchar_t* ptr, int len,
-  int flags)
+int SEC_RAM arduino_16550_uart_write(arduino_16550_uart_state* sp,
+                                     const alt_u8* ptr, int len, int flags)
 {
     alt_irq_context context;
     int             no_block;
     alt_u32         next;
     int             count = len;
 
-    sp->ctrl = IORD_ALTERA_16550_UART_IER(sp->base);
+    sp->ctrl = IORD_ARDUINO_16550_UART_IER(sp->base);
     /*
      * Construct a flag to indicate whether the device is being accessed in
      * blocking or non-blocking mode.
@@ -101,8 +102,8 @@
                 /* Block waiting for space in the circular buffer */
                 /* First, ensure transmit interrupts are enabled to avoid deadlock */
                 context = alt_irq_disable_all ();
-                sp->ctrl |= (ALTERA_16550_UART_IER_ETBEI_MSK);
-                IOWR_ALTERA_16550_UART_IER(sp->base, sp->ctrl);
+                sp->ctrl |= (ARDUINO_16550_UART_IER_ETBEI_MSK);
+                IOWR_ARDUINO_16550_UART_IER(sp->base, sp->ctrl);
                 alt_irq_enable_all (context);
                 /* wait for space to come free */
                 do
@@ -135,8 +136,8 @@
      * drain.
      */
     context = alt_irq_disable_all ();
-    sp->ctrl |= ALTERA_16550_UART_IER_ETBEI_MSK ;
-    IOWR_ALTERA_16550_UART_IER(sp->base, sp->ctrl);
+    sp->ctrl |= ARDUINO_16550_UART_IER_ETBEI_MSK ;
+    IOWR_ARDUINO_16550_UART_IER(sp->base, sp->ctrl);
     alt_irq_enable_all (context);
     /* return the number of bytes written */
     return (len - count);
diff -Naur arduino_16550_uart/inc/arduino_16550_uart_regs.h arduino_16550_uart_mod/inc/arduino_16550_uart_regs.h
--- arduino_16550_uart/inc/arduino_16550_uart_regs.h	2018-11-29 13:30:10.140770249 +0100
+++ arduino_16550_uart_mod/inc/arduino_16550_uart_regs.h	2018-11-29 13:38:34.644765855 +0100
@@ -32,86 +32,86 @@
 
 #include <io.h>
 
-#define IOADDR_ALTERA_16550_UART(base)          \
+#define IOADDR_ARDUINO_16550_UART(base)          \
         __IO_CALC_ADDRESS_NATIVE(base, 0)
 
-#define ALTERA_16550_UART_RBR_OFST              0x00
-#define IORD_ALTERA_16550_UART_RBR(base)        \
-        IORD(base, ALTERA_16550_UART_RBR_OFST)
-
-#define ALTERA_16550_UART_THR_OFST              0x00
-#define IOWR_ALTERA_16550_UART_THR(base, data)  \
-        IOWR(base, ALTERA_16550_UART_THR_OFST, data)
-#define ALTERA_16550_UART_DLL_OFST              0x00
-#define IOWR_ALTERA_16550_UART_DLL(base, data)  \
-        IOWR(base, ALTERA_16550_UART_DLL_OFST, data)
-
-#define ALTERA_16550_UART_IER_OFST              0x01
-#define IOWR_ALTERA_16550_UART_IER(base, data)  \
-        IOWR(base, ALTERA_16550_UART_IER_OFST, data)
-#define IORD_ALTERA_16550_UART_IER(base)  \
-        IORD(base, ALTERA_16550_UART_IER_OFST)
-#define ALTERA_16550_UART_IER_ELSI_MSK          0x00000004    /* Receiver Line Status */
-#define ALTERA_16550_UART_IER_ETBEI_MSK         0x00000002    /* Transmit Holding Register Empty */
-#define ALTERA_16550_UART_IER_ERBFI_MSK         0x00000001    /* Received Data Available */
-
-#define ALTERA_16550_UART_DLH_OFST              0x01
-#define IOWR_ALTERA_16550_UART_DLH(base, data)  \
-        IOWR(base, ALTERA_16550_UART_DLH_OFST, data)
-
-#define ALTERA_16550_UART_IIR_OFST              0x02
-#define IORD_ALTERA_16550_UART_IIR(base)  \
-        IORD(base, ALTERA_16550_UART_IIR_OFST)
-#define ALTERA_16550_UART_FCR_OFST              0x02
-#define IOWR_ALTERA_16550_UART_FCR(base, data)  \
-        IOWR(base, ALTERA_16550_UART_FCR_OFST, data)
-#define ALTERA_16550_UART_FCR_XFIFOR_MSK       0x00000004    /* Tx FIFO reset */
-#define ALTERA_16550_UART_FCR_FIFOR_MSK        0x00000002    /* Rx FIFO reset */
-#define ALTERA_16550_UART_FCR_RT_MSK           0x000000C0    /* Rx Trigger Level */
-#define ALTERA_16550_UART_FCR_TET_MSK          0x00000030    /* Tx Trigger Level */
-#define ALTERA_16550_UART_FCR_FIFOE_MSK        0x00000001    /* FIFO enable */
-
-#define ALTERA_16550_UART_LCR_OFST             0x03
-#define IORD_ALTERA_16550_UART_LCR(base)       \
-        IORD(base, ALTERA_16550_UART_LCR_OFST)
-#define IOWR_ALTERA_16550_UART_LCR(base, data)  \
-        IOWR(base, ALTERA_16550_UART_LCR_OFST, data)
-#define ALTERA_16550_UART_LCR_DLAB_MSK         0x00000080    /* Divisor Latch Access Bit */
-#define ALTERA_16550_UART_LCR_BC_MSK           0x00000040    /* Break Control Bit */
-#define ALTERA_16550_UART_LCR_EPS_MSK          0x00000010    /* Even Parity Select */
-#define ALTERA_16550_UART_LCR_PEN_MSK          0x00000008    /* Parity Enable */
-#define ALTERA_16550_UART_LCR_STOP_MSK         0x00000004    /* Stop Bit */
-#define ALTERA_16550_UART_LCR_DLS_MSK          0x00000103    /* Data Length Select */
-
-#define ALTERA_16550_UART_MCR_OFST             0x4
-#define IOWR_ALTERA_16550_UART_MCR(base, data)  \
-        IOWR(base, ALTERA_16550_UART_MCR_OFST, data)
-#define IORD_ALTERA_16550_UART_MCR(base)        \
-        IORD(base, ALTERA_16550_UART_MCR_OFST)
-#define ALTERA_16550_UART_MCR_AFCE_MSK          0x00000020     /* Hardware Auto Flow Control */
-#define ALTERA_16550_UART_MCR_RTS_MSK           0x00000002     /* Request to send */
-#define ALTERA_16550_UART_MCR_DTR_MSK           0x00000001     /* Data Terminal Ready */
-
-#define ALTERA_16550_UART_LSR_OFST              0x5
-#define IORD_ALTERA_16550_UART_LSR(base)        \
-        IORD(base, ALTERA_16550_UART_LSR_OFST)
-#define IOWR_ALTERA_16550_UART_LSR(base, data)  \
-        IOWR(base, ALTERA_16550_UART_LSR_OFST, data)
-#define ALTERA_16550_UART_LSR_RFE_MSK           0x00000001    /* Receiver FIFO Error */
-#define ALTERA_16550_UART_LSR_TEMT_MSK          0x00000040    /* Transmitter Empty */
-#define ALTERA_16550_UART_LSR_THRE_MSK          0x00000020    /* Transmit Holding Register Empty */
-#define ALTERA_16550_UART_LSR_BI_MSK            0x00000010    /* Break Interrupt */
-#define ALTERA_16550_UART_LSR_FE_MSK            0x00000008    /* Framing Error */
-#define ALTERA_16550_UART_LSR_PE_MSK            0x00000004    /* Parity Error */
-#define ALTERA_16550_UART_LSR_OE_MSK            0x00000002    /* Overrun Error */
-#define ALTERA_16550_UART_LSR_DR_MSK            0x00000001    /* Data Ready */
-#define ALTERA_16550_UART_LCR_STICK_MSK         0X00000020    /* Stick Parity Bit */
-
-#define ALTERA_16550_UART_MSR_OFST              0x6
-#define IORD_ALTERA_16550_UART_MSR(base)        \
-        IORD(base, ALTERA_16550_UART_MSR_OFST)
-#define ALTERA_16550_UART_MSR_CTS_MSK           0x00000001     /* Clear to Send */
+#define ARDUINO_16550_UART_RBR_OFST              0x00
+#define IORD_ARDUINO_16550_UART_RBR(base)        \
+        IORD(base, ARDUINO_16550_UART_RBR_OFST)
+
+#define ARDUINO_16550_UART_THR_OFST              0x00
+#define IOWR_ARDUINO_16550_UART_THR(base, data)  \
+        IOWR(base, ARDUINO_16550_UART_THR_OFST, data)
+#define ARDUINO_16550_UART_DLL_OFST              0x00
+#define IOWR_ARDUINO_16550_UART_DLL(base, data)  \
+        IOWR(base, ARDUINO_16550_UART_DLL_OFST, data)
+
+#define ARDUINO_16550_UART_IER_OFST              0x01
+#define IOWR_ARDUINO_16550_UART_IER(base, data)  \
+        IOWR(base, ARDUINO_16550_UART_IER_OFST, data)
+#define IORD_ARDUINO_16550_UART_IER(base)  \
+        IORD(base, ARDUINO_16550_UART_IER_OFST)
+#define ARDUINO_16550_UART_IER_ELSI_MSK          0x00000004    /* Receiver Line Status */
+#define ARDUINO_16550_UART_IER_ETBEI_MSK         0x00000002    /* Transmit Holding Register Empty */
+#define ARDUINO_16550_UART_IER_ERBFI_MSK         0x00000001    /* Received Data Available */
+
+#define ARDUINO_16550_UART_DLH_OFST              0x01
+#define IOWR_ARDUINO_16550_UART_DLH(base, data)  \
+        IOWR(base, ARDUINO_16550_UART_DLH_OFST, data)
+
+#define ARDUINO_16550_UART_IIR_OFST              0x02
+#define IORD_ARDUINO_16550_UART_IIR(base)  \
+        IORD(base, ARDUINO_16550_UART_IIR_OFST)
+#define ARDUINO_16550_UART_FCR_OFST              0x02
+#define IOWR_ARDUINO_16550_UART_FCR(base, data)  \
+        IOWR(base, ARDUINO_16550_UART_FCR_OFST, data)
+#define ARDUINO_16550_UART_FCR_XFIFOR_MSK       0x00000004    /* Tx FIFO reset */
+#define ARDUINO_16550_UART_FCR_FIFOR_MSK        0x00000002    /* Rx FIFO reset */
+#define ARDUINO_16550_UART_FCR_RT_MSK           0x000000C0    /* Rx Trigger Level */
+#define ARDUINO_16550_UART_FCR_TET_MSK          0x00000030    /* Tx Trigger Level */
+#define ARDUINO_16550_UART_FCR_FIFOE_MSK        0x00000001    /* FIFO enable */
+
+#define ARDUINO_16550_UART_LCR_OFST             0x03
+#define IORD_ARDUINO_16550_UART_LCR(base)       \
+        IORD(base, ARDUINO_16550_UART_LCR_OFST)
+#define IOWR_ARDUINO_16550_UART_LCR(base, data)  \
+        IOWR(base, ARDUINO_16550_UART_LCR_OFST, data)
+#define ARDUINO_16550_UART_LCR_DLAB_MSK         0x00000080    /* Divisor Latch Access Bit */
+#define ARDUINO_16550_UART_LCR_BC_MSK           0x00000040    /* Break Control Bit */
+#define ARDUINO_16550_UART_LCR_EPS_MSK          0x00000010    /* Even Parity Select */
+#define ARDUINO_16550_UART_LCR_PEN_MSK          0x00000008    /* Parity Enable */
+#define ARDUINO_16550_UART_LCR_STOP_MSK         0x00000004    /* Stop Bit */
+#define ARDUINO_16550_UART_LCR_DLS_MSK          0x00000103    /* Data Length Select */
+
+#define ARDUINO_16550_UART_MCR_OFST             0x4
+#define IOWR_ARDUINO_16550_UART_MCR(base, data)  \
+        IOWR(base, ARDUINO_16550_UART_MCR_OFST, data)
+#define IORD_ARDUINO_16550_UART_MCR(base)        \
+        IORD(base, ARDUINO_16550_UART_MCR_OFST)
+#define ARDUINO_16550_UART_MCR_AFCE_MSK          0x00000020     /* Hardware Auto Flow Control */
+#define ARDUINO_16550_UART_MCR_RTS_MSK           0x00000002     /* Request to send */
+#define ARDUINO_16550_UART_MCR_DTR_MSK           0x00000001     /* Data Terminal Ready */
+
+#define ARDUINO_16550_UART_LSR_OFST              0x5
+#define IORD_ARDUINO_16550_UART_LSR(base)        \
+        IORD(base, ARDUINO_16550_UART_LSR_OFST)
+#define IOWR_ARDUINO_16550_UART_LSR(base, data)  \
+        IOWR(base, ARDUINO_16550_UART_LSR_OFST, data)
+#define ARDUINO_16550_UART_LSR_RFE_MSK           0x00000001    /* Receiver FIFO Error */
+#define ARDUINO_16550_UART_LSR_TEMT_MSK          0x00000040    /* Transmitter Empty */
+#define ARDUINO_16550_UART_LSR_THRE_MSK          0x00000020    /* Transmit Holding Register Empty */
+#define ARDUINO_16550_UART_LSR_BI_MSK            0x00000010    /* Break Interrupt */
+#define ARDUINO_16550_UART_LSR_FE_MSK            0x00000008    /* Framing Error */
+#define ARDUINO_16550_UART_LSR_PE_MSK            0x00000004    /* Parity Error */
+#define ARDUINO_16550_UART_LSR_OE_MSK            0x00000002    /* Overrun Error */
+#define ARDUINO_16550_UART_LSR_DR_MSK            0x00000001    /* Data Ready */
+#define ARDUINO_16550_UART_LCR_STICK_MSK         0X00000020    /* Stick Parity Bit */
+
+#define ARDUINO_16550_UART_MSR_OFST              0x6
+#define IORD_ARDUINO_16550_UART_MSR(base)        \
+        IORD(base, ARDUINO_16550_UART_MSR_OFST)
+#define ARDUINO_16550_UART_MSR_CTS_MSK           0x00000001     /* Clear to Send */
 
-#define ALTERA_16550_UART_SCR_OFST              0x7
+#define ARDUINO_16550_UART_SCR_OFST              0x7
 
-#endif /* __ALTERA_16550_UART_REGS_H__ */
+#endif /* __ARDUINO_16550_UART_REGS_H__ */
